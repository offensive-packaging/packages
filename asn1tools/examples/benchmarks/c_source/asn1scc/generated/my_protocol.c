/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "my_protocol.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void D_Initialize(D* pVal)
{
    *pVal = (D) {1,
    {
        0x00
    }
};
}
#endif

 
flag D_IsConstraintValid(const D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 16);
	*pErrCode = ret ? 0 : ERR_D;

	return ret;
}

flag D_Encode(const D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 16);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag D_Decode(D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
	*pErrCode = ret ? 0 : 268435457;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435458;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_c_a_Initialize(C_c_a* pVal)
{
    *pVal = (C_c_a) {    .arr = 
    {
        {1,
            {
                0x00
            }
        }        
    }
};
}
#endif

 
flag C_c_a_IsConstraintValid(const C_c_a* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 3)) {
	    ret = D_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag C_c_a_Encode(const C_c_a* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? C_c_a_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = D_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag C_c_a_Decode(C_c_a* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = D_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void E_Initialize(E* pVal)
{
    *pVal = (E) FALSE;
}
#endif

 
flag E_IsConstraintValid(const E* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag E_Encode(const E* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? E_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag E_Decode(E* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435459;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_d_Initialize(C_d* pVal)
{
    *pVal = (C_d) {
    .a = FALSE
};
}
#endif

 
flag C_d_IsConstraintValid(const C_d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = E_IsConstraintValid(&pVal->a, pErrCode);


	return ret;
}

flag C_d_Encode(const C_d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? C_d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode a */
	    ret = E_Encode(&pVal->a, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag C_d_Decode(C_d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode a */
	ret = E_Decode(&pVal->a, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_c_Initialize(C_c* pVal)
{
    *pVal = (C_c) {
    .kind = C_c_a_PRESENT,
    .u = { .a = {    .arr = 
    {
        {1,
            {
                0x00
            }
        }        
    }
}}
};
}
#endif

 
flag C_c_IsConstraintValid(const C_c* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case C_c_a_PRESENT :
	        ret = C_c_a_IsConstraintValid(&pVal->u.a, pErrCode);
	        break;
	    case C_c_b_PRESENT :
	        ret = E_IsConstraintValid(&pVal->u.b, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag C_c_Encode(const C_c* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? C_c_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case C_c_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = C_c_a_Encode(&pVal->u.a, pBitStrm, pErrCode, FALSE);
	    	break;
	    case C_c_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = E_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag C_c_Decode(C_c* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435460;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = C_c_a_PRESENT;
	    	ret = C_c_a_Decode(&pVal->u.a, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = C_c_b_PRESENT;
	    	ret = E_Decode(&pVal->u.b, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void F_Initialize(F* pVal)
{
    *pVal = (F) -2147483648LL;
}
#endif

 
flag F_IsConstraintValid(const F* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_F;

	return ret;
}

flag F_Encode(const F* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? F_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag F_Decode(F* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : 268435461;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_a_a_Initialize(C_a_a* pVal)
{
    *pVal = (C_a_a) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag C_a_a_IsConstraintValid(const C_a_a* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= 5);
	*pErrCode = ret ? 0 : ERR_C_a_a;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = F_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag C_a_a_Encode(const C_a_a* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? C_a_a_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 5);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = F_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag C_a_a_Decode(C_a_a* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 5);
	*pErrCode = ret ? 0 : 268435462;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = F_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void G_Initialize(G* pVal)
{
    *pVal = (G) 0;
}
#endif

 
flag G_IsConstraintValid(const G* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_G;

	return ret;
}

flag G_Encode(const G* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? G_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag G_Decode(G* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435463;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_a_c_Initialize(C_a_c* pVal)
{
    *pVal = (C_a_c) -40;
}
#endif

 
flag C_a_c_IsConstraintValid(const C_a_c* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-40 <= *pVal && *pVal <= 40);
	*pErrCode = ret ? 0 : ERR_C_a_c;

	return ret;
}

flag C_a_c_Encode(const C_a_c* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? C_a_c_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -40, 40);
    }

	return ret;
}

flag C_a_c_Decode(C_a_c* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -40, 40);
	*pErrCode = ret ? 0 : 268435464;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_a_Initialize(C_a* pVal)
{
    *pVal = (C_a) {
    .a = {    .nCount = 0,    .arr = 
        {
            
        }
    },
    .b = FALSE,
    .c = 0,
    .exist = {
        .b = 1,
        .c = 1
    }
};
}
#endif

 
flag C_a_IsConstraintValid(const C_a* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = C_a_a_IsConstraintValid(&pVal->a, pErrCode);
	if (ret) {
	    if (pVal->exist.b==1) {
	        ret = TRUE; *pErrCode = 0;
	    }
	    if (ret) {
	        if (pVal->exist.c==1) {
	            ret = C_a_c_IsConstraintValid(&pVal->c, pErrCode);
	        }
	    
	    }
	}

	return ret;
}

flag C_a_Encode(const C_a* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? C_a_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.b);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.c);
	        if (ret) {
	            /*Encode a */
	            ret = C_a_a_Encode(&pVal->a, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode b */
	                if (pVal->exist.b) {
	                	BitStream_AppendBit(pBitStrm,pVal->b);
	                }
	                if (ret) {
	                    /*Encode c */
	                    if (pVal->exist.c) {
	                    	ret = C_a_c_Encode(&pVal->c, pBitStrm, pErrCode, FALSE);
	                    }
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag C_a_Decode(C_a* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	unsigned char C_abitMask[1];

	/* Decode Bit Mask for optional and default fields*/
	ret = BitStream_ReadBits(pBitStrm, C_abitMask, 2);
	*pErrCode = ret ? 0 : 268435465;
	if (ret) {
	    if (ret) {
	        if (ret) {
	            /*Decode a */
	            ret = C_a_a_Decode(&pVal->a, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode b */
	                pVal->exist.b = 0;
	                if ((C_abitMask[0] & 0x80) != 0 ) {
	                	pVal->exist.b = 1;
	                	ret = BitStream_ReadBit(pBitStrm, &pVal->b);
	                	*pErrCode = ret ? 0 : 268435466;
	                }
	                if (ret) {
	                    /*Decode c */
	                    {
	                        static C_a_c defValue = 0;
	                        pVal->exist.c = 1;
	                        pVal->c = defValue;
	                        if ((C_abitMask[0] & 0x40) != 0 ) {
	                    	    ret = C_a_c_Decode(&pVal->c, pBitStrm, pErrCode);
	                        }
	                    }
	                
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void C_Initialize(C* pVal)
{
    *pVal = (C) {
    .a = {
        .a = {    .nCount = 0,    .arr = 
            {
                
            }
        },
        .b = FALSE,
        .c = 0,
        .exist = {
            .b = 1,
            .c = 1
        }
    },
    .b = 0,
    .c = {
        .kind = C_c_a_PRESENT,
        .u = { .a = {    .arr = 
        {
            {1,
                {
                    0x00
                }
            }        
        }
    }}
    },
    .d = {
        .a = FALSE
    },
    .exist = {
        .a = 1
    }
};
}
#endif

 
flag C_IsConstraintValid(const C* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	if (pVal->exist.a==1) {
	    ret = C_a_IsConstraintValid(&pVal->a, pErrCode);
	}
	if (ret) {
	    ret = G_IsConstraintValid(&pVal->b, pErrCode);
	    if (ret) {
	        ret = C_c_IsConstraintValid(&pVal->c, pErrCode);
	        if (ret) {
	            ret = C_d_IsConstraintValid(&pVal->d, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag C_Encode(const C* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? C_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.a);
	    if (ret) {
	        /*Encode a */
	        if (pVal->exist.a) {
	        	ret = C_a_Encode(&pVal->a, pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode b */
	            ret = G_Encode(&pVal->b, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c */
	                ret = C_c_Encode(&pVal->c, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode d */
	                    ret = C_d_Encode(&pVal->d, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag C_Decode(C* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	unsigned char CbitMask[1];

	/* Decode Bit Mask for optional and default fields*/
	ret = BitStream_ReadBits(pBitStrm, CbitMask, 1);
	*pErrCode = ret ? 0 : 268435467;
	if (ret) {
	    if (ret) {
	        /*Decode a */
	        pVal->exist.a = 0;
	        if ((CbitMask[0] & 0x80) != 0 ) {
	        	pVal->exist.a = 1;
	        	ret = C_a_Decode(&pVal->a, pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode b */
	            ret = G_Decode(&pVal->b, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c */
	                ret = C_c_Decode(&pVal->c, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode d */
	                    ret = C_d_Decode(&pVal->d, pBitStrm, pErrCode);
	                
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void B_Initialize(B* pVal)
{
    *pVal = (B) {
    .kind = B_a_PRESENT,
    .u = { .a = {
    .a = {
        .a = {    .nCount = 0,    .arr = 
            {
                
            }
        },
        .b = FALSE,
        .c = 0,
        .exist = {
            .b = 1,
            .c = 1
        }
    },
    .b = 0,
    .c = {
        .kind = C_c_a_PRESENT,
        .u = { .a = {    .arr = 
        {
            {1,
                {
                    0x00
                }
            }        
        }
    }}
    },
    .d = {
        .a = FALSE
    },
    .exist = {
        .a = 1
    }
}}
};
}
#endif

 
flag B_IsConstraintValid(const B* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case B_a_PRESENT :
	        ret = C_IsConstraintValid(&pVal->u.a, pErrCode);
	        break;
	    case B_b_PRESENT :
	        ret = D_IsConstraintValid(&pVal->u.b, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306372;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag B_Encode(const B* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? B_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case B_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = C_Encode(&pVal->u.a, pBitStrm, pErrCode, FALSE);
	    	break;
	    case B_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = D_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306373;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag B_Decode(B* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435468;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = B_a_PRESENT;
	    	ret = C_Decode(&pVal->u.a, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = B_b_PRESENT;
	    	ret = D_Decode(&pVal->u.b, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306374;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void A_Initialize(A* pVal)
{
    *pVal = (A) {    .nCount = 1,    .arr = 
    {
        {
            .kind = B_a_PRESENT,
            .u = { .a = {
            .a = {
                .a = {    .nCount = 0,    .arr = 
                    {
                        
                    }
                },
                .b = FALSE,
                .c = 0,
                .exist = {
                    .b = 1,
                    .c = 1
                }
            },
            .b = 0,
            .c = {
                .kind = C_c_a_PRESENT,
                .u = { .a = {    .arr = 
                {
                    {1,
                        {
                            0x00
                        }
                    }        
                }
            }}
            },
            .d = {
                .a = FALSE
            },
            .exist = {
                .a = 1
            }
        }}
        }        
    }
};
}
#endif

 
flag A_IsConstraintValid(const A* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (2 <= pVal->nCount && pVal->nCount <= 5);
	*pErrCode = ret ? 0 : ERR_A;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = B_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag A_Encode(const A* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? A_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 2, 5);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = B_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag A_Decode(A* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 2, 5);
	*pErrCode = ret ? 0 : 268435469;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = B_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void PDU_b_Initialize(PDU_b* pVal)
{
    *pVal = (PDU_b) {
    .kind = PDU_b_a_PRESENT,
    .u = { .a = {    .nCount = 1,    .arr = 
    {
        {
            .kind = B_a_PRESENT,
            .u = { .a = {
            .a = {
                .a = {    .nCount = 0,    .arr = 
                    {
                        
                    }
                },
                .b = FALSE,
                .c = 0,
                .exist = {
                    .b = 1,
                    .c = 1
                }
            },
            .b = 0,
            .c = {
                .kind = C_c_a_PRESENT,
                .u = { .a = {    .arr = 
                {
                    {1,
                        {
                            0x00
                        }
                    }        
                }
            }}
            },
            .d = {
                .a = FALSE
            },
            .exist = {
                .a = 1
            }
        }}
        }        
    }
}}
};
}
#endif

 
flag PDU_b_IsConstraintValid(const PDU_b* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case PDU_b_a_PRESENT :
	        ret = A_IsConstraintValid(&pVal->u.a, pErrCode);
	        break;
	    case PDU_b_b_PRESENT :
	        ret = B_IsConstraintValid(&pVal->u.b, pErrCode);
	        break;
	    case c_PRESENT :
	        ret = C_IsConstraintValid(&pVal->u.c, pErrCode);
	        break;
	    case d_PRESENT :
	        ret = D_IsConstraintValid(&pVal->u.d, pErrCode);
	        break;
	    case e_PRESENT :
	        ret = E_IsConstraintValid(&pVal->u.e, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306375;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag PDU_b_Encode(const PDU_b* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? PDU_b_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PDU_b_a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	    	ret = A_Encode(&pVal->u.a, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PDU_b_b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	    	ret = B_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    case c_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	    	ret = C_Encode(&pVal->u.c, pBitStrm, pErrCode, FALSE);
	    	break;
	    case d_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	    	ret = D_Encode(&pVal->u.d, pBitStrm, pErrCode, FALSE);
	    	break;
	    case e_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	    	ret = E_Encode(&pVal->u.e, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306376;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag PDU_b_Decode(PDU_b* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 4);
	*pErrCode = ret ? 0 : 268435470;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = PDU_b_a_PRESENT;
	    	ret = A_Decode(&pVal->u.a, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PDU_b_b_PRESENT;
	    	ret = B_Decode(&pVal->u.b, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = c_PRESENT;
	    	ret = C_Decode(&pVal->u.c, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = d_PRESENT;
	    	ret = D_Decode(&pVal->u.d, pBitStrm, pErrCode);
	    	break;
	    case 4:
	    	pVal->kind = e_PRESENT;
	    	ret = E_Decode(&pVal->u.e, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306377;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void PDU_Initialize(PDU* pVal)
{
    *pVal = (PDU) {
    .a = -2147483648LL,
    .b = {
        .kind = PDU_b_a_PRESENT,
        .u = { .a = {    .nCount = 1,    .arr = 
        {
            {
                .kind = B_a_PRESENT,
                .u = { .a = {
                .a = {
                    .a = {    .nCount = 0,    .arr = 
                        {
                            
                        }
                    },
                    .b = FALSE,
                    .c = 0,
                    .exist = {
                        .b = 1,
                        .c = 1
                    }
                },
                .b = 0,
                .c = {
                    .kind = C_c_a_PRESENT,
                    .u = { .a = {    .arr = 
                    {
                        {1,
                            {
                                0x00
                            }
                        }        
                    }
                }}
                },
                .d = {
                    .a = FALSE
                },
                .exist = {
                    .a = 1
                }
            }}
            }        
        }
    }}
    }
};
}
#endif

 
flag PDU_IsConstraintValid(const PDU* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = F_IsConstraintValid(&pVal->a, pErrCode);
	if (ret) {
	    ret = PDU_b_IsConstraintValid(&pVal->b, pErrCode);
	
	}

	return ret;
}

flag PDU_Encode(const PDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? PDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode a */
	    ret = F_Encode(&pVal->a, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode b */
	        ret = PDU_b_Encode(&pVal->b, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag PDU_Decode(PDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode a */
	ret = F_Decode(&pVal->a, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode b */
	    ret = PDU_b_Decode(&pVal->b, pBitStrm, pErrCode);
	
	}


	return ret;
}

